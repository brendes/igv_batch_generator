#! /usr/bin/env python3

# File: batch_generator.py
# Package: igv_batch_generator

__author__ = 'Edward J. Stronge'
__email__ = 'ejstronge@gmail.com'

import argparse
import csv
import time

from collections import namedtuple

"""batch_generator.py

Creates a list of commands that can later be run in IGV from a list of
loci specified in a CSV file.
"""


# TODO
# How to extract tracknames?
# Will I need to set a sleep interval between commands because of latency of X11 forwarding?
# TODO Not clear if we need to call genome after 'new'
# Can sort based on bp or range. Sort options are:
# base, position, strand, quality, sample,  readGroup, AMPLIFICATION,
# DELETION, EXPRESSION, SCORE, and MUTATION_COUNT
# May not need to expand...

IGV_SCRIPT_HEADER = """# IGV Script Generated by igv_batch_generator %s
# See https://www.broadinstitute.org/software/igv/PortCommands 

new
genome hg19

snapshotDirectory %s
# maxPanelHeight (default is 100)
maxPanelHeight 1000
"""

IGV_SCRIPT_BODY_FRAGMENT = """
new
load {bam_file}
goto chr{chromosome}:{position}
sort quality
expand
snapshot chr{chromosome}-{position}-expanded.png
collapse
snapshot chr{chromosome}-{position}-collapsed.png
"""

IGV_SCRIPT_FOOTER = """
exit
"""

SAMPLE_BAM_MAPPING_LOCATION = "/home/roi/work/r_walsh/0_data/ejs/all_sample_UMB_brains.txt"

def generate_igv_script(snv_tups, sample_bam_map, header, footer):
    """Given (sample, chromosome, position) tuples, generate IGV commands
    to obtain snapshots of each specified locus
    
    sample_bam_map is a dictionary of sample IDs and their corresponding
    BAM file
    """
    script_body = ''
    for snv_tup in snv_tups:
        if snv_tup.sampleID not in sample_bam_map:
            # This must be a sample that we don't have a BAM for - this could happen
            # when different data sources (HSPH, Park Lab, etc.) haven't yet completed
            # the same analyses.
            print("WARNING - sample %s (chr%s, %s) will not be snapshotted!" % (
                snv_tup.sampleID, snv_tup.chromosome, snv_tup.position))
            continue
        script_body += IGV_SCRIPT_BODY_FRAGMENT.format(
            bam_file=sample_bam_map[snv_tup.sampleID],
            chromosome=snv_tup.chromosome,
            position=snv_tup.position)
    return header + script_body + footer

def parse_cli_args():
    """Parse args and begin batch file generation"""
    
    # Set up the command-line interface
    parser = argparse.ArgumentParser(
        description="Generate IGV batch script from Excel file of interesting loci")
    parser.add_argument('-b', '--batch-file-name', 
        default=time.strftime('%Y%m%d%H%M%S_igv_batch_script.igv'),
        help="File containing the output IGV commands")
    parser.add_argument('-m', '--sample-name-to-sample-bam-map', default=SAMPLE_BAM_MAPPING_LOCATION,
        help="Text file with tab-delimited sample names and corresponding BAM directories. \
                Currently set to %s" % SAMPLE_BAM_MAPPING_LOCATION)
    parser.add_argument('-d', '--snapshot-output-directory', required=True,
        help="Directory (**ON ORCHESTRA**) for resulting screenshots. THIS DIRECTORY \
        MUST EXIST BEFORE RUNNING THE IGV BATCH SCRIPT.")
    parser.add_argument('csv_of_interesting_loci',
        help="CSV (not Excel) file containing at least three columns: 'SampleID', \
        'CHROM' and 'POS'") 
    args = parser.parse_args()

    with open(args.sample_name_to_sample_bam_map) as sample_bam_map_file:
        sample_bam_map = dict()
        for row in sample_bam_map_file:
            k, v = row.split()
            sample_bam_map[k] = v
            assert k in v # Sanity check - is the sample name contained in the filename?

    # This works just like a normal tuple but with the additional benefit of allowing named access
    # (i.e., locus_tuple.sampleID vs. locus_tupe[0])
    LocusDataTuple = namedtuple('LocusDataTuple', ['sampleID', 'chromosome', 'position'])
    with open(args.csv_of_interesting_loci) as locus_file:
        reader = csv.DictReader(locus_file)
        locus_data = list()
        for row in reader:
            # Make tuple w/ the data we need. Not strictly necessary to make the tuple
            # here but this facilitates testing downstream functions
            locus_data.append(LocusDataTuple(row['SampleID'], row['CHROM'], row['POS']))
    
    with open(args.batch_file_name, 'w+') as batch_output_file:
        full_igv_script = generate_igv_script(
            locus_data, sample_bam_map,
            header=IGV_SCRIPT_HEADER % (
                time.strftime('at %H:%M:%S on %Y-%m-%d'), args.snapshot_output_directory),
            footer=IGV_SCRIPT_FOOTER)
        batch_output_file.write(full_igv_script)

if __name__ == '__main__':
    parse_cli_args()

